### (#52) Mobile robot navigation

Ability to move in space avoiding obstacles (static or dynamic)

Solving robot navigation involves answering 3 questions: Where am I? Where am I going? How do I get there? 

Two types:

* Map-based navigation: the robot uses a map of environment, i.e. has apriori knowledge of global environment and obstacles and uses it to plan the path to the destination 
* Reactive navigation: the robot uses only local info from its surroundings obtained from sensors

### (#53) Map-based navigation

Requires a Localization function, Finding the location of the destination and Motion planning/Path planning  i.e. planning its path to the destination avoiding obstacles.

3 fundamental navigation functions:

* **Localization**: the  robot needs to obtain its location expressed in global coordinates or in reference to an address (e.g. name of a room or street). This is done using some sensor input e.g. GPS, laser range finders, cameras, ultrasound sensors, received signal strength, etc.  

* **Mapping**: robot needs a map to recognize its environment and provide meaning to directions and locations. It can be loaded in memory or generated gradually during exploration. There are different representations e.g. graph or matrix
* **Motion planning (or Path planning)**: requires an address that the robot understands to specify well the goal pose/target destination. Addresses can also expressed in coordinates either absolute (in global frame) or relative (e.g. in the robot frame)

SLAM (Simultaneous Localization And Mapping) is the process of building a map from sensors while the robot explores an unknown area. Detected obstacles are stored in a data structure and the robot keeps updating it as it goes, based on the estimations of its own location and the distance to obstacles. This process typically uses filtering (Kalman, particle) to attenuate errors of range sensor measurements and odometry.

Three main ROS packages  in the navigation/SLAM stack:

* `move_base`: allows the robot to navigate in a map and move to a goal pose with respect to a given frame

* `gmapping`: creates maps using laser scan data

* `amcl`: responsible for localization using an existing map

### (#54) SLAM Demo

Launch the gazebo simulation environment of a Turtlebot3 waffle in a house scenario:

```bash
$ export TURTLEBOT3_MODEL=waffle
$ roslaunch turtlebot3_gazebo turtlebot3_house.launch
```

Open `gmapping` SLAM application: opens RVIZ and builds the map

```bash
$ export TURTLEBOT3_MODEL=waffle_pi
$ roslaunch turtlebot3_slam turtlebot3_slam.launch slam_methods:=gmapping
```

Launch Teleop: allows moving the robot around with keyboard and build the map while moving 

```bash
$ export TURTLEBOT3_MODEL=waffle_pi
$ roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch
```

Save the map:

```bash
$ rosrun map_server map_saver -f ./map
```

The map is a 2D matrix representing a grid of cells 5-50cm in size depending on resolution. A cell has 3 possible states: that can be empty (1, white) occupied (0, black) or unknown if undecided or not unexplored (grey). For each cell there is a probability of occupancy 0-100% or -1 if unexplored.

ROS support different SLAM algorithms:

* `gmapping`: a ROS wrapper for OpenSlam's gmapping algorithm for laser-based SLAM. ([Docs](http://wiki.ros.org/gmapping))
* `cartographer`: real-time SLAM in 2D and 3D by Google for multiple platforms & sensor configs. ([Docs](https://google-cartographer-ros.readthedocs.io/en/latest/))
* `hector_slam`: does not require odometry ([Docs](http://wiki.ros.org/hector_slam))

Initially all cells marked as unknown. Robot starts laser scanning and measures the distance to the obstacle and marks cells corresponding to the obstacle as occupied and all others in the path as free. Sometimes laser feedback is not accurate (e.g. obstacle out of range) so cells remain in unknown state
